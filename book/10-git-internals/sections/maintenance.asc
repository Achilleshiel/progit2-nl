=== Onderhoud en gegevensherstel

Bij tijd en wijle, moet je wat opschonen - een repository iets compacter maken, een geimporteerde repository
 opschonen of verloren gegane werk herstellen.
Deze paragraaf zal een aantal van deze scenarios behandelen.

[[_git_gc]]
==== Onderhoud

Op gezette tijden roept Git automatisch een commando genaamd ``auto gc'' aan.
Meestal zal dit commando niets doen.
Echter, als er teveel losse objecten zijn (objecten die niet in een packfile zitten) of teveel packfiles, roept Git
 een volwaardige `git gc` commando aan.
Het ``gc'' staat voor vuil ophalen (garbage collect), en het commando voert een aantal dingen uit: het verzamelt alle
 losse objecten en zet ze in packfiles, het consolideert packfiles in een grote packfile, en het verwijdert objecten
 die onbereikbaar zijn vanaf enig commit en een aantal maanden oud zijn.

Je kunt auto gc ook handmatig aanroepen als volgt:

[source,console]
----
$ git gc --auto
----

Nogmaals, over het algemeen doet dit niets.
Je moet ongeveer 7.000 losse objecten hebben of meer dan 50 packfiles om Git een echte gc commando te laten aanroepen.
Je kunt deze grenswaarden aanpassen met respectievelijk het `gc.auto` en `gc.autopacklimit` configuratie waarden.

Het andere wat `gc` zal doen is je referenties in een enkel bestand stoppen.
Stel dat je repository de volgende branches en tags bevat:

[source,console]
----
$ find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1
----

Als je `git gc` aanroept, zal je deze bestanden niet langer in de `refs` directory hebben staan.
Git verplaatst ze allemaal in het kader van efficiëntie naar een bestand met de naam `.git/packed-refs` die er
 als volgt uit ziet:
If you run `git gc`, you'll no longer have these files in the `refs` directory.
Git will move them for the sake of efficiency into a file named `.git/packed-refs` that looks like this:

[source,console]
----
$ cat .git/packed-refs
# pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9
----

Als je een referentie bijwerkt, werkt Git dit bestand niet bij, maar schrijft in plaats daarvan een nieuw bestand
 naar `refs/heads`.
Om de juiste SHA-1 voor een gegeven refentie te pakken te krijgen, zoekt Git de referentie eerst in de `refs`
 directory en daarna het `packed-refs` bestand als achtervang.
Dus, als je een referentie niet kunt vinden in de `refs` directory, staat deze waarschijnlijk in je `packed-refs`
 bestand.

Let even op de laatste regel van het bestand, die begint met een `^`.
Dit geeft aan dat de tag directory erboven een geannoteerde tag is, en deze regel de commit is waar de geannoteerde
 tag naar verwijst.

[[_data_recovery]]
==== Gegevensherstel

Op een bepaald punt in je Git reis, kan je per ongeluk een commit kwijt raken.
Meestal gebeurt dit omdat je een branch 'force-delete' waar werk op zat, en je komt erachter dat je die branch toch
 nog nodig had; of je hebt een branch ge-'hard-reset', en daarmee commits laat vallen waar je toch nog iets van wilde
 gebruiken.
Aangenomen dat dit gebeurd is, hoe kan je die commits nog terughalen?

Hier is een voorbeeld die de master branch hard-reset in je test repository naar een oudere commit en daarna de
 verloren commits herstelt.
Laten we eerst eens zien hoe je repository er op dit moment uitziet:

[source,console]
----
$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Nu gaan we de `master` branch terugzetten naar de middelste commit:

[source,console]
----
$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Je bent effectief de bovenste twee commits kwijtgeraakt - je hebt geen branch waar deze commits vanaf bereikt kunnen
 worden.
Je moet de SHA-1 van de laatste commit zien te vinden en dan een branch toevoegen die daarnaar wijst.
De truuk is het vinden van de SHA-1 van die laatste commit - we mogen aannemen dat je deze niet uit je hoofd hebt
 geleerd, toch?

Vaak is de snelste manier om een instrument genaamd `git reflog` te gebruiken.
Als je aan het werk bent, houdt Git stilletjes bij wat je HEAD was elke keer als je het verandert.
Elke keer als je commit, of branches wijzigt, wordt de reflog bijgewerkt.
De reflog wordt ook bijgewerkt door het `git update-ref` commando, wat nog een reden is om dit te gebruiken in plaats
 van alleen de SHA-1 waarden naar je ref bestanden te schrijven, zoals we besproken hebben in <<_git_refs>>.
Je kunt zien waar je op enig moment geweest bent door `git reflog` aan te roepen:

[source,console]
----
$ git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: modified repo.rb a bit
484a592 HEAD@{2}: commit: added repo.rb
----

Hier kunnen we de twee commits zien die we uitgechecked hebben gehad, maar hier is ook niet veel informatie te zien.
Om dezelfde informatie op een veel nuttiger manier te zien, kunnen we `git log -g` aanroepen, die je een normale log
 uitvoer voor je reflog laat zien.

[source,console]
----
$ git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: updating HEAD
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:22:37 2009 -0700

		third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: updating HEAD
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri May 22 18:15:24 2009 -0700

       modified repo.rb a bit
----

Het lijkt erop dat de laatste commit degene is die je kwijt was, dus je kunt deze terughalen door een nieuwe branch
 te maken op die commit.
Bijvoorbeeld, je kunt een branch genaamd `recover-branch` beginnen op die commit (ab1afef):

[source,console]
----
$ git branch recover-branch ab1afef
$ git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit
----

Toppie - nu heb je een branch genaamd `recover-branch` die staat waar je `master` branch heeft gestaan, en de eerste
 twee commits worden weer bereikbaar.
Okay, nu stel dat je verlies om wat voor reden dan ook niet meer in de reflog zichtbaar is - je kunt dat naspelen
 door `recover-branch` weg te halen en de reflog weg te gooien.
Nu kan je op geen enkele manier meer bij die eerste twee commits:

[source,console]
----
$ git branch -D recover-branch
$ rm -Rf .git/logs/
----

Omdat de reflog gegevens worden bewaard in de `.git/logs/` directory, heb je effectief geen reflog.
Hoe kan je nu die commit herstellen?
Een manier is om het `git fsck` instrument te gebuiken die je database op integriteit controleert.
Als je het aanroept met de `--full` optie, zal het je alle objecten laten zien waar geen enkele andere object naar
 verwijst:

[source,console]
----
$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293
----

In this case, you can see your missing commit after the string ``dangling commit''.
You can recover it the same way, by adding a branch that points to that SHA-1.

[[_removing_objects]]
==== Removing Objects

There are a lot of great things about Git, but one feature that can cause issues is the fact that a `git clone` downloads the entire history of the project, including every version of every file.
This is fine if the whole thing is source code, because Git is highly optimized to compress that data efficiently.
However, if someone at any point in the history of your project added a single huge file, every clone for all time will be forced to download that large file, even if it was removed from the project in the very next commit.
Because it's reachable from the history, it will always be there.

This can be a huge problem when you're converting Subversion or Perforce repositories into Git.
Because you don't download the whole history in those systems, this type of addition carries few consequences.
If you did an import from another system or otherwise find that your repository is much larger than it should be, here is how you can find and remove large objects.

*Be warned: this technique is destructive to your commit history.*
It rewrites every commit object since the earliest tree you have to modify to remove a large file reference.
If you do this immediately after an import, before anyone has started to base work on the commit, you're fine – otherwise, you have to notify all contributors that they must rebase their work onto your new commits.

To demonstrate, you'll add a large file into your test repository, remove it in the next commit, find it, and remove it permanently from the repository.
First, add a large object to your history:

[source,console]
----
$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz > git.tgz
$ git add git.tgz
$ git commit -m 'add git tarball'
[master 7b30847] add git tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tgz
----

Oops – you didn't want to add a huge tarball to your project.
Better get rid of it:

[source,console]
----
$ git rm git.tgz
rm 'git.tgz'
$ git commit -m 'oops - removed large tarball'
[master dadf725] oops - removed large tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tgz
----

Now, `gc` your database and see how much space you're using:

[source,console]
----
$ git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)
----

You can run the `count-objects` command to quickly see how much space you're using:

[source,console]
----
$ git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0
----

The `size-pack` entry is the size of your packfiles in kilobytes, so you're using almost 5MB.
Before the last commit, you were using closer to 2K – clearly, removing the file from the previous commit didn't remove it from your history.
Every time anyone clones this repository, they will have to clone all 5MB just to get this tiny project, because you accidentally added a big file.
Let's get rid of it.

First you have to find it.
In this case, you already know what file it is.
But suppose you didn't; how would you identify what file or files were taking up so much space?
If you run `git gc`, all the objects are in a packfile; you can identify the big objects by running another plumbing command called `git verify-pack` and sorting on the third field in the output, which is file size.
You can also pipe it through the `tail` command because you're only interested in the last few largest files:

[source,console]
----
$ git verify-pack -v .git/objects/pack/pack-29…69.idx \
  | sort -k 3 -n \
  | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438
----

The big object is at the bottom: 5MB.
To find out what file it is, you'll use the `rev-list` command, which you used briefly in <<_enforcing_commit_message_format>>.
If you pass `--objects` to `rev-list`, it lists all the commit SHA-1s and also the blob SHA-1s with the file paths associated with them.
You can use this to find your blob's name:

[source,console]
----
$ git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz
----

Now, you need to remove this file from all trees in your past.
You can easily see what commits modified this file:

[source,console]
----
$ git log --oneline --branches -- git.tgz
dadf725 oops - removed large tarball
7b30847 add git tarball
----

You must rewrite all the commits downstream from `7b30847` to fully remove this file from your Git history.
To do so, you use `filter-branch`, which you used in <<_rewriting_history>>:

[source,console]
----
$ git filter-branch --index-filter \
  'git rm --cached --ignore-unmatch git.tgz' -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref 'refs/heads/master' was rewritten
----

The `--index-filter` option is similar to the `--tree-filter` option used in <<_rewriting_history>>, except that instead of passing a command that modifies files checked out on disk, you're modifying your staging area or index each time.

Rather than remove a specific file with something like `rm file`, you have to remove it with `git rm --cached` – you must remove it from the index, not from disk.
The reason to do it this way is speed – because Git doesn't have to check out each revision to disk before running your filter, the process can be much, much faster.
You can accomplish the same task with `--tree-filter` if you want.
The `--ignore-unmatch` option to `git rm` tells it not to error out if the pattern you're trying to remove isn't there.
Finally, you ask `filter-branch` to rewrite your history only from the `7b30847` commit up, because you know that is where this problem started.
Otherwise, it will start from the beginning and will unnecessarily take longer.

Your history no longer contains a reference to that file.
However, your reflog and a new set of refs that Git added when you did the `filter-branch` under `.git/refs/original` still do, so you have to remove them and then repack the database.
You need to get rid of anything that has a pointer to those old commits before you repack:

[source,console]
----
$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)
----

Let's see how much space you saved.

[source,console]
----
$ git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
----

The packed repository size is down to 8K, which is much better than 5MB.
You can see from the size value that the big object is still in your loose objects, so it's not gone; but it won't be transferred on a push or subsequent clone, which is what is important.
If you really wanted to, you could remove the object completely by running `git prune` with the `--expire` option:

[source,console]
----
$ git prune --expire now
$ git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0
----
