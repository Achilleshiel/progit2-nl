=== Uitwisseling protocollen

Git kan op twee belangrijke manieren gegevens uitwisselen tussen twee repositories: het ``domme'' (dumb) protocol en het
 ``slimme'' (smart) protocol.
In dit gedeelte zal de manier van werken van beide snel worden besproken.

==== Het domme protocol

ALs je een repository opzet die alleen gelezen hoeft te worden via HTTP, is het domme protocol het meest
 waarschijnlijke zijn die zal worden gebruikt.
Dit protocol wordt ``dom'' genoemd omdat het geen Git-specifieke code nodig heeft aan de kant van de server tijdens
 het uitwisselingsproces; het fetch proces is een reeks van HTTP `GET` requests, waar het werkstation aannames mag
 doen over de inrichting van de Git repository op de server.

[NOTE]
====
Het domme protocol wordt tegenwoordig nog maar sporadisch gebruikt.
Het is moeilijk te beveiligen of te schermen, dus de meeste Git hosts (zowel in de cloud als op locatie) zullen het
 weigeren te gebruiken.
Het wordt over het algemeen aangeraden om het slimme protocol te gebruiken, die we iets verderop zullen bespreken.
====

Laten we het `http-fetch` proces voor de simplegit library eens volgen:

[source,console]
----
$ git clone http://server/simplegit-progit.git
----

Het eerste wat dit commando doet is het `info/refs` bestand pullen.
Dit bestand wordt geschreven door het `update-server-info` commando, wat de reden is waarom je dit als `post-receive`
 hook moet activeren om het uitwisselen via HTTP goed te laten werken:

[source]
----
=> GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master
----

Nu heb je een lijst met de remote referenties en SHA-1 waarden.
Vervolgens ga je op zoek naar de HEAD referentie zodat je weet wat je moet uitchecken als je klaar bent:

[source]
----
=> GET HEAD
ref: refs/heads/master
----

Je moet de `master` branch uitchecken als je het proces hebt voltooid.
Op dit punt ben je gereed om het proces te doorlopen.
Omdat je vertrekpunt het `ca82a6` commit object is die je in het `info/refs` bestand zag, begin je met die te fetchen:

[source]
----
=> GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)
----

Je krijgt een object terug - dat object is in los (loose) formaat op de server, en je hebt het met een statische HTTP
 GET request gefetched.
Je kunt het nu met zlib-uncompress uitpakken, de header ervan afhalen, en naar de commit inhoud kijken:

[source,console]
----
$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon <schacon@gmail.com> 1205815931 -0700
committer Scott Chacon <schacon@gmail.com> 1240030591 -0700

changed the version number
----

Vervolgens heb je nog twee objecten op t halen - `cfda3b`, wat de boom met inhoud is waar de commit die we zojuist
 opgehaald hebben naar wijst, en `085bb3`, dat de ouder-commit is:

[source]
----
=> GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)
----

En daarmee krijg je je volgende commit object.
Haal het boom-object op:

[source]
----
=> GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)
----

Oeps, het ziet er naar uit dat het boom-object niet in los formaat op de server is, dus je krijgt een 404 antwoord.
Hier zijn een aantal oorzaken voor - het object kan in een andere repository zitten, of het zou in een packfile in
 deze repository kunnen zitten.
Git controleert eerst of er alternatieven zijn opgegeven:

[source]
----
=> GET objects/info/http-alternates
(empty file)
----

Dit geeft een lijst met alternatieve URLs terug, Git controleert daar op losse  bestanden en packfiles - dit is een
 leuk mechanisme voor projecten die forks zijn van elkaar zijn om objecten te delen op schijf.
Echter, omdat er in dit geval geen alternatieven worden gegeven, moet het object in een packfile zitten.
Om te zien welke packfiles er beschikbaar zijn op deze server, moet je het `objects/info/packs` bestand te pakken
 krijgen, waar een opsomming hiervan in staat (wat ook door de `update-server-info` wordt gegenereerd):

[source]
----
=> GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
----

Er is maar een packfile op de server, dus het is duidelijk dat jouw object daar in zit, maar je gaat het index
 bestand toch controleren om er zeker van te zijn.
Dit is ook handig als je meerdere packfiles op de server hebt, omdat je dan kan zien welk packfile het object wat je
 nodig hebt bevat:

[source]
----
=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)
----

Nu je de packfile index hebt, kan je kijken of jouw object daar in zit - omdat de index de SHA-1 waarden van de
 objecten bevat die in de packfile zitten en de relatieve afstand naar deze objecten.
Jouw object is er, dus ga je gang en haal de hele packfile op:

[source]
----
=> GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)
----

Je hebt je boom object, dus je gaat verder met je commits af te lopen.
Die zitten ook allemaal in de packfile die je zoujuist hebt gedownload, dus je hoeft geen verzoeken meer te doen naar
 je server.
Git checkt een werk-kopie van de `master` branch uit waarnaar werd verwezen door de HEAD referentie die je aan het
 begin hebt gedownload.

==== Het slimme protocol

Het domme protocol is eenvoudig, maar een beetje inefficiënt, het kan geen gegevens aan die van het werkstation naar
 de server moet worden geschreven.
Het slimme protocol is een meer gebruikelijke methode van gegevens uit te wisselen, maar het heeft een proces aan de
 remote kant nodig die op de hoogte is van Git - het moet lokale gegevens kunnen lezen, uitvinden wat het werkstation
 al heeft en nog nodig heeft, en een op maat gemaakte packfile hiervoor maken.
Er zijn twee groepen van processen voor het uitwisselen van gegevens: een paar voor het uploaden van gegevens en een
 paar het downloaden van gegevens.

===== Uploading Data

(((git commands, send-pack)))(((git commands, receive-pack)))
To upload data to a remote process, Git uses the `send-pack` and `receive-pack` processes.
The `send-pack` process runs on the client and connects to a `receive-pack` process on the remote side.

====== SSH

For example, say you run `git push origin master` in your project, and `origin` is defined as a URL that uses the SSH protocol.
Git fires up the `send-pack` process, which initiates a connection over SSH to your server.
It tries to run a command on the remote server via an SSH call that looks something like this:

[source,console]
----
$ ssh -x git@server "git-receive-pack 'simplegit-progit.git'"
005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1+github-607-gfba4028 delete-refs
003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic
0000
----

The `git-receive-pack` command immediately responds with one line for each reference it currently has – in this case, just the `master` branch and its SHA-1.
The first line also has a list of the server's capabilities (here, `report-status`, `delete-refs`, and some others, including the client identifier).

Each line starts with a 4-character hex value specifying how long the rest of the line is.
Your first line starts with 005b, which is hexadecimal for 91, meaning that 91 bytes remain on that line.
The next line starts with 003e, which is 62, so you read the remaining 62 bytes.
The next line is 0000, meaning the server is done with its references listing.

Now that it knows the server's state, your `send-pack` process determines what commits it has that the server doesn't.
For each reference that this push will update, the `send-pack` process tells the `receive-pack` process that information.
For instance, if you're updating the `master` branch and adding an `experiment` branch, the `send-pack` response may look something like this:

[source]
----
0085ca82a6dff817ec66f44342007202690a93763949  15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000
----

Git sends a line for each reference you're updating with the line's length, the old SHA-1, the new SHA-1, and the reference that is being updated.
The first line also has the client's capabilities.
The SHA-1 value of all '0's means that nothing was there before – because you're adding the experiment reference.
If you were deleting a reference, you would see the opposite: all '0's on the right side.

Next, the client sends a packfile of all the objects the server doesn't have yet.
Finally, the server responds with a success (or failure) indication:

[source]
----
000Aunpack ok
----

====== HTTP(S)

This process is mostly the same over HTTP, though the handshaking is a bit different.
The connection is initiated with this request:

[source]
----
=> GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
000000ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master \
	report-status delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000
----

That's the end of the first client-server exchange.
The client then makes another request, this time a `POST`, with the data that `git-upload-pack` provides.

[source]
----
=> POST http://server/simplegit-progit.git/git-receive-pack
----

The `POST` request includes the `send-pack` output and the packfile as its payload.
The server then indicates success or failure with its HTTP response.

===== Downloading Data

(((git commands, fetch-pack)))(((git commands, upload-pack)))
When you download data, the `fetch-pack` and `upload-pack` processes are involved.
The client initiates a `fetch-pack` process that connects to an `upload-pack` process on the remote side to negotiate what data will be transferred down.

====== SSH

If you're doing the fetch over SSH, `fetch-pack` instead runs something like this:

[source,console]
----
$ ssh -x git@server "git-upload-pack 'simplegit-progit.git'"
----

After `fetch-pack` connects, `upload-pack` sends back something like this:

[source]
----
00dfca82a6dff817ec66f44342007202690a93763949 HEADmulti_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000
----

This is very similar to what `receive-pack` responds with, but the capabilities are different.
In addition, it sends back what HEAD points to (`symref=HEAD:refs/heads/master`) so the client knows what to check out if this is a clone.

At this point, the `fetch-pack` process looks at what objects it has and responds with the objects that it needs by sending ``want'' and then the SHA-1 it wants.
It sends all the objects it already has with ``have'' and then the SHA-1.
At the end of this list, it writes ``done'' to initiate the `upload-pack` process to begin sending the packfile of the data it needs:

[source]
----
0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0000
0009done
----

====== HTTP(S)

The handshake for a fetch operation takes two HTTP requests.
The first is a `GET` to the same endpoint used in the dumb protocol:

[source]
----
=> GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
000000e7ca82a6dff817ec66f44342007202690a93763949 HEADmulti_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000
----

This is very similar to invoking `git-upload-pack` over an SSH connection, but the second exchange is performed as a separate request:

[source]
----
=> POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000
----

Again, this is the same format as above.
The response to this request indicates success or failure, and includes the packfile.

==== Protocols Summary

This section contains a very basic overview of the transfer protocols.
The protocol includes many other features, such as `multi_ack` or `side-band` capabilities, but covering them is outside the scope of this book.
We've tried to give you a sense of the general back-and-forth between client and server; if you need more knowledge than this, you'll probably want to take a look at the Git source code.
